---
layout: page
permalink: /talk/multiple-inheritance-and-mixins/
---

<div class="speaker-wrapper">
<a href="/speaker/dane-hillard/">
  <div class="speaker-img-wrapper">
    <img class="speaker-img-large" src="https://secure.gravatar.com/avatar/9da94e6b6107563a68d185a02137a32e?s=500" />
      <h3>Dane Hillard</h3>
  </div>
    </a>
  <div class="uk-grid">
    <div class="uk-width-4-1">
      <h1>Multiple Inheritance and Mixins</h1>
    </div>
  </div>
</div>
<br/>
<div>
    <h3>Audience: Intermediate</h3>
</div>
<br/>
<div class="talk_content">

    <h3>Description:</h3>
    <p>At the advent of object-oriented programming, inheritance and the class hierarchy reigned supreme. You could model _anything_, from `Animal` all the way down to `Animal` -> `Mammal` -> `Dog` -> `UtilityDog` -> `FrenchBulldog`. Eventually this got out of hand.

Today, composition brings many of the benefits of complex inheritance while keeping functionality focused and isolated. In many languages, composition is achieved via the interface pattern; an object can declare its intent to _implement_ a particular interface and as a result is beholden to support the behaviors that interface outlines. In Python, there is no such thing as an interface! What do we do about that?

Fortunately, Python provides the ability to support something interface-like (and more) via _multiple inheritance_. In multiple inheritance, an object may inherit from multiple other objects. Let's explore how this works, what pitfalls to look out for, and how not to repeat the past when dealing with class hierarchies.</p>
    
</div>

